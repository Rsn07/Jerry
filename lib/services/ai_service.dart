import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
import 'package:shared_preferences/shared_preferences.dart';

class AIService {
  static const String openRouterKeyPref = 'openrouter_key';
  static const String hfKeyPref = 'hf_key';

  Widget settingsPage(BuildContext context) {
    return const SettingsPage();
  }

  Future<Map<String, String>> generateProject(String prompt) async {
    final prefs = await SharedPreferences.getInstance();
    final openRouterKey = prefs.getString(openRouterKeyPref) ?? '';
    final hfKey = prefs.getString(hfKeyPref) ?? '';

    // If you prefer hard-coded keys for quick local testing, replace the placeholders below:
    // const hardOpenRouter = 'YOUR_OPENROUTER_KEY_HERE';
    // const hardHf = 'YOUR_HUGGINGFACE_KEY_HERE';
    // then use them like: final openRouterKey = hardOpenRouter;

    final systemPrompt = 'You are a helpful assistant. Return ONLY a valid JSON object mapping filenames to file contents. Example: { "index.html":"...","style.css":"...","script.js":"..." }';
    final userPrompt = 'Create a simple responsive website for: "\$prompt". Return JSON only.';

    if (openRouterKey.isNotEmpty) {
      try {
        final resp = await http.post(
          Uri.parse('https://api.openrouter.ai/v1/chat/completions'),
          headers: {'Authorization': 'Bearer \$openRouterKey', 'Content-Type': 'application/json'},
          body: jsonEncode({
            'model': 'gpt-3.5-mini',
            'messages': [
              {'role': 'system', 'content': systemPrompt},
              {'role': 'user', 'content': userPrompt}
            ]
          }),
        );
        if (resp.statusCode == 200) {
          final j = jsonDecode(resp.body);
          final text = j['choices'][0]['message']['content'] as String;
          final parsed = _parseJsonFromString(text);
          if (parsed.isNotEmpty) return parsed;
        }
      } catch (e) {}
    }

    if (hfKey.isNotEmpty) {
      try {
        final model = 'gpt2';
        final url = 'https://api-inference.huggingface.co/models/\$model';
        final resp = await http.post(Uri.parse(url),
            headers: {'Authorization': 'Bearer \$hfKey', 'Content-Type': 'application/json'},
            body: jsonEncode({'inputs': '\$systemPrompt\n\n\$userPrompt', 'options': {'wait_for_model': true}}));
        if (resp.statusCode == 200) {
          final decoded = jsonDecode(resp.body);
          if (decoded is List) {
            final text = decoded[0]['generated_text'] as String? ?? '';
            final parsed = _parseJsonFromString(text);
            if (parsed.isNotEmpty) return parsed;
          } else if (decoded is Map && decoded.containsKey('generated_text')) {
            final text = decoded['generated_text'] as String;
            final parsed = _parseJsonFromString(text);
            if (parsed.isNotEmpty) return parsed;
          }
        }
      } catch (e) {}
    }

    return _fallbackFiles(prompt);
  }

  Map<String, String> _fallbackFiles(String prompt) {
    final html = '''
<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="stylesheet" href="style.css">
<title>\$prompt</title>
</head>
<body>
  <div class="container">
    <h1>\$prompt</h1>
    <p>Lightweight offline template generated by Jerry.</p>
  </div>
  <script src="script.js"></script>
</body>
</html>''';
    final css = '''
:root{--bg:#0f1724;--accent:#3b82f6}
body{font-family:Arial,Helvetica,sans-serif;background:var(--bg);color:#e6eef8;margin:0;padding:18px}
.container{max-width:900px;margin:32px auto}h1{color:var(--accent)}''';
    final js = "console.log('Jerry project loaded.');";
    return {'index.html': html, 'style.css': css, 'script.js': js};
  }

  Map<String, String> _parseJsonFromString(String s) {
    try {
      final start = s.indexOf('{');
      final end = s.lastIndexOf('}');
      if (start >= 0 && end > start) {
        final jsonStr = s.substring(start, end + 1);
        final decoded = jsonDecode(jsonStr) as Map<String, dynamic>;
        return decoded.map((k, v) => MapEntry(k.toString(), v.toString()));
      }
    } catch (e) {}
    return {};
  }
}

class SettingsPage extends StatefulWidget {
  const SettingsPage({super.key});
  @override
  State<SettingsPage> createState() => _SettingsPageState();
}

class _SettingsPageState extends State<SettingsPage> {
  final TextEditingController orController = TextEditingController();
  final TextEditingController hfController = TextEditingController();

  @override
  void initState() {
    super.initState();
    _load();
  }

  void _load() async {
    final prefs = await SharedPreferences.getInstance();
    orController.text = prefs.getString(AIService.openRouterKeyPref) ?? '';
    hfController.text = prefs.getString(AIService.hfKeyPref) ?? '';
    setState(() {});
  }

  void _save() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(AIService.openRouterKeyPref, orController.text.trim());
    await prefs.setString(AIService.hfKeyPref, hfController.text.trim());
    ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Saved keys')));
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Settings - API Keys')),
      body: Padding(
        padding: const EdgeInsets.all(12.0),
        child: Column(children: [
          TextField(controller: orController, decoration: const InputDecoration(labelText: 'OpenRouter API Key (optional)')),
          const SizedBox(height: 8),
          TextField(controller: hfController, decoration: const InputDecoration(labelText: 'Hugging Face API Key (optional)')),
          const SizedBox(height: 12),
          ElevatedButton(onPressed: _save, child: const Text('Save Keys')),
          const SizedBox(height: 12),
          const Text('If both blank, Jerry will use an offline fallback template.'),
        ]),
      ),
    );
  }
}
